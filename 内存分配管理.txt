Linux 的虚拟内存管理有几个关键概念： 
1、每个进程都有独立的虚拟地址空间，进程访问的虚拟地址并不是真正的物理地址； 
2、虚拟地址可通过每个进程上的页表(在每个进程的内核虚拟地址空间)与物理地址进行映射，获得真正物理地址；
3、如果虚拟地址对应物理地址不在物理内存中，则产生缺页中断，真正分配物理地址，同时更新进程的页表；如果此时物理内存已耗尽，则根据内存替换算法淘汰部分页面至物理磁盘中。

Linux 虚拟地址空间如何分布？ 
Linux 使用虚拟地址空间，大大增加了进程的寻址空间，由低地址到高地址分别为： 
1、只读段：该部分空间只能读，不可写；(包括：代码段等) 
2、数据段：保存全局变量、静态变量的空间； 
3、堆 ：就是平时所说的动态内存， malloc/new 大部分都来源于此。其中堆顶的位置可通过函数 brk 和 sbrk 进行动态调整。 
4、文件映射区域：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。 
5、栈：用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看。 
6、内核虚拟空间：用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)。 
下图是 32 位系统典型的虚拟地址空间分布(来自《深入理解计算机系统》)。

发成缺页中断后，执行了那些操作？
当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作： 
1、检查要访问的虚拟地址是否合法 
2、查找/分配一个物理页 
3、填充物理页内容（读取磁盘，或者直接置0，或者啥也不干） 
4、建立映射关系（虚拟地址到物理地址） 重新执行发生缺页中断的那条指令 如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。

内存分配的原理
从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。
1、malloc小于128k的内存，使用brk分配内存，将_edata往高地址推，此时只分配虚拟空间，不涉及物理内存，
当第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系
2、malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)


malloc/free函数案例分析
1、进程启动的时候，其（虚拟）内存空间的初始布局如图1所示：【为了简单起见，省略了内存映射文件】
1.1、_edata指针（glibc里面定义）指向数据段的最高地址
1.2、mmap内存映射文件是在堆和栈的中间
[!image](https://github.com/lobo-a/linux-note/blob/main/resources/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D1.jpeg)
2、进程调用A=malloc(30K)以后，内存空间如图2
备注：_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，当进程第一次读写A这块内存的时候，发生缺页中断，内核才分配A这块内存对应的物理页；如没有发生缺页中断，物理页是不会被分配的。
3、进程调用B=malloc(40K)以后，内存空间如图3
4、进程调用C=malloc(200K)以后，内存空间如图4
5、进程调用D=malloc(100K)以后，内存空间如图5
6、进程调用free(C)，如图6所示
6.1、C对应的虚拟内存和物理内存一起释放
7、进程调用free(B)，如图7所示
7.1、B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢，没法处理
8、进程调用free(D)以后，如图8所示
8.1、B和D连接起来，变成一块140K的空闲内存，发现最高地址空闲内存超过128K，于是内存紧缩
9、如图9所示，当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。
