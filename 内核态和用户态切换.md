### 概要：

对于cpu来说都是执行指令，不存在用户态和内核态之分，是内核系统出于对系统安全运行的一种保护机制；

对于重要操作权限收敛，主要是内存初始化和对物理硬件操作相关，并提供统一的对外调用接口

### 1.进程的堆栈

1.1、内核在创建进程的时候，在创建task_struct的同事，会为进程创建相应的堆栈。

1.2、每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈[空栈]，存在于内核空间。

1.3、当进程在用户空间运行时，cpu堆栈指针寄存器里面的内容是用户栈地址，使用用户栈；

1.4、当进程在内核空间运行时，cpu堆栈指针寄存器里面的内容是内核栈地址，使用内核栈。

### 2.进程用户栈和内核栈的切换

2.1、当进程因为中断或者系统调用而陷入内核态之行时，进程所使用的堆栈也要从用户栈转到内核栈。

2.2、当进程陷入内核态后，先把用户态堆栈的地址保存在内核栈之中【压栈】，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换；

2.3、当进程从内核态恢复到用户态时，在内核态的最后内核栈里面的用户栈的地址恢复到堆栈指针寄存器即可。这样就实现了内核栈和用户栈的互转。

### 3.从内核转到用户态时用户栈的地址是在陷入内核的时候保存在内核栈里面的，但是在陷入内核的时候，我们是如何知道内核栈的地址的呢？

3.1、在进程从用户态转到内核态的时候，进程的内核栈总是空的。

3.2、因为当进程在用户态运行时，使用的是用户栈，当进程陷入到内核态时，内核栈保存进程在内核态运行的相关信息，但是一旦进程返回到用户态后，内核栈中保存的信息无效，会全部恢复，

3.3、因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。

### 4.为何要设置两个不同的栈

4.1、共享原因：内核的代码和数据是为所有的进程共享的，如果不为每一个进程设置对应的内核栈，那么就不能实现不同的进程执行不同的代码。

4.2、安全原因：如果只有一个栈，那么用户就可以修改栈内容来突破内核安全保护。

### 5.kernel-2.4.x内核栈的实现是：
```
Union task_union {
    Struct task_struct task;
    Unsigned long stack[[INIT_STACK_SIZE/sizeof(long)] // INIT_STACK_SIZE的大小只能是8K
}
```

内核为每个进程分配task_struct结构体的时候，实际上分配两个连续的物理页面，底部用作task_struct结构体，结构上面的用作栈，可以理解task_struct和栈是一体的大小为8K连续空间
